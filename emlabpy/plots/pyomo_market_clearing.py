from io import StringIO
import pandas as pd
import pyomo.environ as pyo
from optimutils import summarise_results

# Sample data for generators
generators = {
    'Gen1': {'capacity': 20, 'cost_coeff': 3},  # Linear cost function: c(x) = a * x
    'Gen2': {'capacity': 20, 'cost_coeff': 4},  # Linear cost function: c(x) = a * x
    'Gen3': {'capacity': 20, 'cost_coeff': 5},  # Linear cost function: c(x) = a * x
    'Gen4': {'capacity': 20, 'cost_coeff': 6},  # Linear cost function: c(x) = a * x
    'Gen5': {'capacity': 150, 'cost_coeff': 20},  # Linear cost function: c(x) = a * x
}

# Sample data for consumers
consumers = {
    'Consumer1': {'demand': 80, 'valuation': 15},   # Valuation for consumption
    'Consumer2': {'demand': 120, 'valuation': 10},  # Valuation for consumption
}

# Create Pyomo Concrete Model
model = pyo.ConcreteModel()
model.dual = pyo.Suffix(direction=pyo.Suffix.IMPORT)
# Sets
model.G = pyo.Set(initialize=generators.keys())  # Set of generators
model.C = pyo.Set(initialize=consumers.keys())   # Set of consumers

# Binary variables indicating whether a generator is active
model.gen_on = pyo.Var(model.G, domain=pyo.Binary)

# Variables
model.PG = pyo.Var(model.G, domain=pyo.NonNegativeReals)  # Power generated by each generator

# Objective function: maximize total welfare
def total_welfare(model):
    consumer_surplus = sum(consumers[c]['valuation'] * consumers[c]['demand'] for c in model.C)
    generator_cost = sum(generators[gen]['cost_coeff'] * generators[gen]['capacity'] for gen in model.G)
    return consumer_surplus - generator_cost

model.obj = pyo.Objective(rule=total_welfare, sense=pyo.maximize)

# Constraint: demand from consumers must be met
def demand_constraint(model, c):
    return sum(model.PG[gen] for gen in model.G) >= consumers[c]['demand']
# Constraint: generator capacity constraint
def capacity_constraint(model, gen):
    return model.PG[gen] <= generators[gen]['capacity'] * model.gen_on[gen]

def capacity_constraint_min(model, gen):
    return model.PG[gen] >= generators[gen]['capacity'] * model.gen_on[gen]

model.demand_constraint = pyo.Constraint(model.C, rule=demand_constraint)
model.capacity_constraint = pyo.Constraint(model.G, rule=capacity_constraint)
model.capacity_constraint_min = pyo.Constraint(model.G, rule=capacity_constraint_min)
# Solve the model
solver = pyo.SolverFactory('glpk')  # Choose a solver
results = solver.solve(model)

# Print results
print("Optimal Solution:")
for gen in model.G:
    print(f"{gen}: {pyo.value(model.PG[gen]):.2f} MW, {'On' if pyo.value(model.gen_on[gen]) == 1 else 'Off'}")

print("Total Welfare:", pyo.value(model.obj))